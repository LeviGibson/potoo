<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Potoo</title>
  <link rel="icon" type="image/x-icon" href="./favicon.ico">
  <style>
    body { font-family: sans-serif; padding: 20px; max-width: 600px; margin: auto; }
    input, button { font-size: 1rem; padding: 0.5rem; margin: 0.2rem; }
    #solutions { margin-top: 20px; list-style-type: decimal; max-height: 300px; overflow-y: auto; }

    #solutions {
      background-color: #f2f2f2;   /* light gray */
      padding: 10px;
      border-radius: 6px;
    }

    #solutions li {
      padding: 4px 6px;
      margin: 2px 0;
    }

    body {
  font-family: sans-serif;
}

#overlay {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background: rgba(0, 0, 0, 0.5);
  display: flex;
  align-items: center;
  justify-content: center;
}

#overlay.hidden {
  display: none;
}

.modal {
  background: white;
  padding: 20px;
  border-radius: 8px;
  width: 300px;

  max-height: 80vh;        /* ← key line */
  overflow-y: auto;       /* ← key line */
}

.modal label {
  display: block;
  margin: 10px 0;
}

.buttons {
  text-align: right;
  margin-top: 15px;
}

.container {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(120px, 1fr));
      gap: 8px;
      max-width: 500px;
    }
    label {
      cursor: pointer;
      user-select: none;
    }

  </style>
</head>
<body>
  <h1 style="text-align: center;">Potoo</h1>
  <h5 style="text-align: center;">An OO Solver for 2x2</h5>

  <label for="scramble">Enter scramble:</label>
  <input type="text" id="scramble" placeholder="R U R' U'" size="40">
  <div id="error" style="color: red; display: none;">
  please enter only valid notation (&ltR U F&gt)
</div>

<script>
  const input = document.getElementById("scramble");
  const error = document.getElementById("error");

  // Regex for a single move: R, R', R2, etc.
  const moveRegex = /^[RUF](?:'|2)?$/;

  function isValidScramble(text) {
    if (text.trim() === "") return true; // allow empty
    return text
      .trim()
      .split(/\s+/)
      .every(move => moveRegex.test(move));
  }

  input.addEventListener("input", () => {
    if (isValidScramble(input.value)) {
      document.getElementById("startBtn").disabled = false;
      input.style.border = "";
      error.style.display = "none";
    } else {
      document.getElementById("startBtn").disabled = true;
      input.style.border = "2px solid red";
      error.style.display = "block";
    }
  });
</script>

  <button id="startBtn" disabled>Start Solver</button>
  <button id="settingsBtn">⚙️ Settings</button>

<label for="range">Max Depth: <span id="val">12</span></label>
<input type="range" id="range" min="8" max="16" value="12" oninput="updateLabel(this.value)">


<div id="overlay" class="hidden">
  <div class="modal">
    <h2>Settings</h2>

    <label>
      <input type="checkbox" id="showScores">
      Show Scores
    </label>
    <label>
      <input type="checkbox" id="algGeneratingCheckbox">
      Ignore Pre/Post AUF
    </label>

    <!-- <label>
      <input type="checkbox" id="gegCheckbox">
      GEG mode
    </label> -->

    <h3>Allowed Angles</h3>
    <button id="selectAllRotations">Select All</button>
    <button id="selectNoneRotations">Select None</button>

    <div class="container" id="checkboxContainer"></div>


    <div class="buttons">
      
      <button id="closeBtn">Close</button>
    </div>
  </div>
</div>

<!-- JavaScript -->
<script>
  var maxDepth = 12;
function updateLabel(val) {
  document.getElementById('val').innerText = val;
  maxDepth = val;
}
</script>
  <h3 id="depthIndicator">Waiting</h3>

  <ul id="solutions"></ul>

  <script type="module">
    import createModule from "./potoo.js";

    let wasmModule;

    // Initialize WASM module
    async function initWASM() {
      wasmModule = await createModule();
      console.log("WASM module loaded");

      // Call exported C++ init_all function
      wasmModule._init_all();

      // Enable start button
      document.getElementById("startBtn").disabled = false;
    }

    initWASM();

    const startBtn = document.getElementById("startBtn");
    const clearBtn = document.getElementById("clearBtn");
    const solutionsList = document.getElementById("solutions");

    // Called from EM_JS in C++ after each depth
    var solutions = []; // { score: number, alg: string }

window.update = async function() {
  await sleep(10);
}

var lastUpdate = 0;

window.addSolution = function(message) {
  const commaIndex = message.indexOf(",");
  if (commaIndex === -1) return;

  // console.log(message);

  const score = parseInt(message.slice(0, commaIndex), 10);
  const alg = message.slice(commaIndex + 1);

  if (Number.isNaN(score)) return;

  // Store solution
  solutions.push({ score, alg });

  // Sort by score (lowest first)
  solutions.sort((a, b) => a.score - b.score);


  // const unixTimeInSeconds = (Date.now() / 1000);
  // if (unixTimeInSeconds - lastUpdate >= 1){
    renderSolutions();
  //   lastUpdate = unixTimeInSeconds;

  // }

  // Re-render list
};

var showScores = document.getElementById("showScores").checked;

function renderSolutions() {
  const list = document.getElementById("solutions");
  list.innerHTML = "";
  var solutionsDisplayed = 0;

  for (const { score, alg } of solutions) {
    if (score < 10000000){
      const li = document.createElement("li");
      var rotations = alg.split(")")[0].split("(")[1];
      // console.log(alg);
      // console.log(rotations);
      if (rotations.length == 0){
        rotations = "None"
      }
      if (allowedRotations.includes(rotations)){
        if (showScores){
          li.textContent = `${alg} (Score: ${(score/600).toFixed(2)}s)`;
        } else {
          li.textContent = `${alg}`;
        }
        
        list.appendChild(li);

        solutionsDisplayed++;
        if (solutionsDisplayed > 100){
          break;
        }
    }
    }
  }
}

  const rotationOptions = [
    "x2 y", "z'", "x", "x2 y2", "x y'", "z y'",
    "x2 y'", "z y2", "x' y2", "x2", "x' y",
    "z' y", "y", "z' y2", "x'", "y2",
    "x' y'", "z y", "y'", "z", "x y2",
    "None", "x y", "z' y'"
  ];

  // Global list
  let allowedRotations = [...rotationOptions];

  const container = document.getElementById("checkboxContainer");

  rotationOptions.forEach(option => {
    const label = document.createElement("label");
    const checkbox = document.createElement("input");

    checkbox.type = "checkbox";
    checkbox.className = "rotationCheckbox"
    checkbox.checked = true;

    checkbox.addEventListener("change", () => {
      if (checkbox.checked) {
        if (!allowedRotations.includes(option)) {
          allowedRotations.push(option);
        }
      } else {
        allowedRotations = allowedRotations.filter(v => v !== option);
      }
      renderSolutions();
    });

    label.appendChild(checkbox);
    label.append(" " + option);
    container.appendChild(label);
  });

const settingsBtn = document.getElementById("settingsBtn");
  const overlay = document.getElementById("overlay");
  const closeBtn = document.getElementById("closeBtn");
  const selectAllRotationsBtn = document.getElementById("selectAllRotations");
  const selectNoneRotationsBtn = document.getElementById("selectNoneRotations");

  selectAllRotationsBtn.onclick = () => {
    var checkboxes = document.getElementsByClassName("rotationCheckbox");
    for (const box of checkboxes){
      box.checked = true;
      const changeEvent = new Event('change', { bubbles: true });
      box.dispatchEvent(changeEvent);

    }
  };

  selectNoneRotationsBtn.onclick = () => {
    var checkboxes = document.querySelectorAll(".rotationCheckbox");
    for (const box of checkboxes){
      box.checked = false;
      const changeEvent = new Event('change', { bubbles: false });
      box.dispatchEvent(changeEvent);
    }
  };

  settingsBtn.onclick = () => {
    overlay.classList.remove("hidden");
  };

  closeBtn.onclick = () => {
    overlay.classList.add("hidden");
  };

  // Optional: click outside modal to close
  overlay.onclick = (e) => {
    if (e.target === overlay) {
      overlay.classList.add("hidden");
    }
  };

  document.getElementById("showScores").addEventListener("change", e => {
    showScores = e.target.checked;
    renderSolutions();
  });

    startBtn.onclick = () => {
  const scramble = document.getElementById("scramble").value.trim();
const lengthBytes = wasmModule.lengthBytesUTF8(scramble) + 1; // +1 for null terminator
const ptr = wasmModule._malloc(lengthBytes);

// Copy JS string into WASM memory
wasmModule.stringToUTF8(scramble, ptr, lengthBytes);

// Call your C++ function with pointer
// wasmModule._start_solver(ptr, document.getElementById("algGeneratingCheckbox").checked, document.getElementById("gegCheckbox").checked);
wasmModule._start_solver(ptr, document.getElementById("algGeneratingCheckbox").checked, 0);

// Free memory afterwards (optional)
wasmModule._free(ptr);
    iterate();


};

    function sleep(ms) {
      return new Promise(resolve => setTimeout(resolve, ms));
    }

    async function iterate() {
      solutions = [];
      var depth = 7;
      while (depth <= maxDepth){
        document.getElementById("depthIndicator").textContent = `Searching Depth ${depth}`
        wasmModule._increase_depth();
        await sleep(100);
        depth++;
      }
      document.getElementById("depthIndicator").textContent = `Search Finished`
    }


  </script>
  <footer>
 <small>&copy; Copyright 2026, Levi Gibson</small>
</footer>

</body>

</html>
